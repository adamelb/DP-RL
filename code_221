# This notebook builds a compact set of plots to compare 3 models across 50 stocks.
# Provide your data in the variable `means` (shape: 50 x 3). Each row is a stock; columns are models.
# Optionally provide `stock_names` (length 50) and `model_names` (length 3).
#
# If you don't define these, this cell will generate a synthetic example so you can see the layout.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from pathlib import Path

# -------------------------
# 1) INPUTS (edit these)
# -------------------------
try:
    means  # check if user already defined `means` in the session
except NameError:
    # Synthetic example (remove after you paste your real array)
    rng = np.random.default_rng(42)
    means = rng.normal(loc=[0.05, 0.06, 0.055], scale=[0.02, 0.022, 0.018], size=(50, 3))
    means = means.clip(min=-0.1, max=0.2)

try:
    stock_names
except NameError:
    stock_names = [f"Stock {i+1}" for i in range(means.shape[0])]

try:
    model_names
except NameError:
    model_names = ["Model A", "Model B", "Model C"]

# Validate shapes
assert means.shape[1] == 3, f"`means` must have 3 columns (got {means.shape[1]})."
assert means.shape[0] == len(stock_names), "`stock_names` length must match number of rows in `means`."
assert len(model_names) == 3, "`model_names` must have length 3."

# -------------------------
# 2) ORGANIZE THE DATA
# -------------------------
n_stocks, n_models = means.shape

# Long-form DataFrame for summaries and some plots
df_long = pd.DataFrame({
    "stock": np.repeat(stock_names, n_models),
    "model": np.tile(model_names, n_stocks),
    "metric": means.ravel()
})

# Model-level summary stats
summary = (
    df_long.groupby("model")["metric"]
    .agg(mean="mean", std="std", median="median", min="min", max="max")
    .reset_index()
)

# Win counts: for each stock, which model has the highest metric?
winners_idx = means.argmax(axis=1)  # index of best model per stock
win_counts = pd.Series(winners_idx).value_counts().reindex(range(3), fill_value=0)
summary["wins"] = [win_counts.get(i, 0) for i in range(3)]
summary["win_share"] = summary["wins"] / n_stocks

# Spread per stock (max - min across models)
spreads = means.max(axis=1) - means.min(axis=1)

# Save a tidy CSV too (optional)
out_dir = Path("/mnt/data/model_vs_stock_plots")
out_dir.mkdir(parents=True, exist_ok=True)
summary_path = out_dir / "model_summary.csv"
df_long_path = out_dir / "data_long.csv"
summary.to_csv(summary_path, index=False)
df_long.to_csv(df_long_path, index=False)

# -------------------------
# 3) PLOTS (matplotlib, single chart per figure, default colors)
# -------------------------

# 3.1 Heatmap: stocks (rows) × models (cols)
fig1 = plt.figure(figsize=(6, 8))
plt.imshow(means, aspect="auto")
plt.xticks(ticks=range(3), labels=model_names, rotation=0)
# Show only a subset of y-ticks to avoid crowding if many stocks
step = max(1, n_stocks // 10)
plt.yticks(ticks=list(range(0, n_stocks, step)), labels=[stock_names[i] for i in range(0, n_stocks, step)])
plt.colorbar(label="Metric")
plt.title("Performance Heatmap: Stocks × Models")
plt.xlabel("Model")
plt.ylabel("Stock")
heatmap_path = out_dir / "heatmap_stocks_by_models.png"
plt.tight_layout()
plt.savefig(heatmap_path, dpi=150)
plt.show()

# 3.2 Distribution per model: boxplot of metric across stocks
fig2 = plt.figure(figsize=(6, 4))
# Collect per-model arrays in order
data_per_model = [means[:, i] for i in range(3)]
plt.boxplot(data_per_model, labels=model_names, showfliers=True)
plt.title("Distribution of Performance per Model")
plt.ylabel("Metric")
boxplot_path = out_dir / "boxplot_model_distributions.png"
plt.tight_layout()
plt.savefig(boxplot_path, dpi=150)
plt.show()

# 3.3 Win counts: number of stocks where each model is best
fig3 = plt.figure(figsize=(6, 4))
plt.bar(model_names, summary["wins"].values)
plt.title("Win Count by Model (Best per Stock)")
plt.ylabel("Number of Stocks Won")
bar_wins_path = out_dir / "bar_wins.png"
plt.tight_layout()
plt.savefig(bar_wins_path, dpi=150)
plt.show()

# 3.4 Spread across models per stock (max - min), sorted
fig4 = plt.figure(figsize=(7, 4))
sorted_spreads = np.sort(spreads)[::-1]
plt.plot(range(1, n_stocks + 1), sorted_spreads)
plt.title("Per-Stock Spread (max - min across models)")
plt.xlabel("Stocks (sorted by spread)")
plt.ylabel("Spread")
spread_path = out_dir / "spread_sorted.png"
plt.tight_layout()
plt.savefig(spread_path, dpi=150)
plt.show()

# 3.5 Ranked lines: each model's metric across stocks sorted by the mean across models
# Sort stocks by average metric to align comparisons
sort_idx = means.mean(axis=1).argsort()[::-1]
ranked = means[sort_idx]
fig5 = plt.figure(figsize=(7, 4))
for i in range(3):
    plt.plot(ranked[:, i], label=model_names[i])
plt.title("Per-Stock Performance (Stocks sorted by average metric)")
plt.xlabel("Stocks (sorted)")
plt.ylabel("Metric")
plt.legend()
ranked_lines_path = out_dir / "ranked_lines.png"
plt.tight_layout()
plt.savefig(ranked_lines_path, dpi=150)
plt.show()

# Show a compact, useful summary table
from caas_jupyter_tools import display_dataframe_to_user
display_dataframe_to_user("Model summary (downloadable CSV available)", summary)

# Let the user know where files are
print("Saved files:")
print(f"- Summary CSV: {summary_path}")
print(f"- Long-form data CSV: {df_long_path}")
print(f"- Heatmap: {heatmap_path}")
print(f"- Boxplot: {boxplot_path}")
print(f"- Win counts bar: {bar_wins_path}")
print(f"- Spread plot: {spread_path}")
print(f"- Ranked lines plot: {ranked_lines_path}")